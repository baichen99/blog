---
title: 流水线数据冲突等问题
date: 2021-07-09 23:47:31
tags:
- 考研
- 计算机组成原理
- 流水线
- 数据冲突
categories:
- 计算机组成原理
- 考研
---

## 五段流水线

通常指令周期分为五个部分：

1. IF(Instruction Fetch) 取指
2. ID(Instruction Decode)译码&取数
3. EX(Execute) 执行
4. M/MEM(Memory) 访存
5. WB(Write back)写回寄存器

![](https://raw.githubusercontent.com/baichen99/pics/master/img/%E6%88%AA%E5%B1%8F2021-07-09%20%E4%B8%8B%E5%8D%8811.53.18.png)

### 基本流程

简单介绍一下指令执行过程，**注意：以下不是所有指令都具有，只是为了方便设计流水线，每个指令周期都有这几个机器周期，但周期内可能为空指令，具体会在后面对不同种类指令进行讨论。**

1. IF阶段，根据PC值从指令cache中取出指令，并将指令放在指令寄存器中，这是每个指令都要做的
2. ID阶段，对指令译码，并从cache中取操作数(取不到则从主存找)，并存放到ID段的锁存器中，这里有三个：A、B、Imm，Imm代表立即数
3. EX阶段，ALU将上一步得到的操作信息进行运算，运算结果放入EX段锁存器
4. M阶段，
5. WB阶段，将数据写回寄存器

### 运算类指令

如ADD，SUB，SHL等，其指令周期为：

1. IF
2. ID，取出需要进行运算的操作数
3. EX，将运算结果放入寄存器中，等待WB阶段写回寄存器
4. **M ，空段**，因为运算器运算的结果肯定是要直接放入某个寄存器中，因此不需要访存，例如ADD Rs, Rd的功能为$(Rs)+(Rd) \rarr Rd$，无访存阶段
5. WB

### LOAD指令

LOAD Rd,996(Rs)，其功能为$(996 + (Rs)) \rarr Rd$，通常情况下，LOAD指令都要使用基址寻址，从表达式中可以看出进行了加法运算，因此必定有EX阶段

1. IF，每个指令都要有这个阶段
2. ID，将基地址(Rs)取出，放到锁存器A中，偏移量的值放入Imm中
3. EX，得到有效地址EA
4. M，从cache的EA地址取数，并存放到锁存器
5. WB，将该数写回Rd寄存器

### STORE指令

STORE Rs, 996(Rd)，其功能为$Rs \rarr (996+(Rd))$，其前三个步骤都与LOAD一样

4. M，写入数据到cache，这一步就完成了STORE指令目的
5. **WB，空**

### 条件转移

采用相对寻址，如beq Rs, Rt, #偏移量，其功能为：若Rs==Rt，则(PC) + 指令字长 + (偏移量x指令字长) -> PC，否则(PC) + 指令字长 -> PC(即顺序执行)

> 注：跳转到相对于下一条指令的偏移地址

1. IF
2. ID，取出要比较的两个数，放入A、B锁存器，偏移量放入Imm中
3. EX，运算，比较两个数
4. M，不访存，这个阶段更新PC值
5. **WB， 空**

### 条件转移

采用相对寻址，如jmp #偏移量，其功能为：(PC) + 指令字长 + (偏移量x指令字长) -> PC

> 注：跳转到相对于下一条指令的偏移地址

1. IF
2. ID，偏移量放入Imm中
3. EX，这个阶段更新PC值
4. **M，空**
5. **WB， 空**

## 数据冲突

### RAW

### WAR

### WAW



## 考试形式

#### 例1

在无转发机制的五段基本流水线（取指、译码/读寄存器、运算、访存、写回寄存器）中，下列指令存在数据冒险的指令对是（）

I1: add R1, R2, R3; (R2) + (R3) -> R1

I2: add R5, R2, R4; (R2) + (R4) -> R5

I3: add R4, R5, R3; (R5) + (R3) -> R4

I4: add R5, R2, R6; (R2) + (R6) -> R5

A I1, I2

B I2, I3

C I2, I4

D I3, I4



| 指令 | 1 | 2 | 3 | 4 | 5 | 6 |
| ---- | ---- | ---------- | ---------- | ---- | ------ | ------ |
| I1 | IE   | ID(R2, R3) | EX         | M    | WB(R1) ||
| I2 |      | IE         | ID(R2, R4) | EX   | M      |WB(R5)|

可以看到I1在5写的寄存器R1和I2使用到的寄存器无关，因此不存在冲突，继续添加指令
| 指令 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| ---- | ---- | ---------- | ---------- | ---- | ------ | ------ | ------ |
| I1 | IE   | ID(R2, R3) | EX         | M          | WB(R1) |       |  |
| I2 |      | IE         | ID(R2, R4) | EX         | M      |WB(R5) |  |
| I3 |      |            | IE         | ID(R5, R3) |        |       |  |

写到这一步发现，I3在4要读R5，但是上一条指令还没写完，于是便出现了RAW冲突，所以选B

解决方法是等待

| 指令 | 1    | 2          | 3          | 4     | 5      | 6      | 7          | 8    | 9     | 10     |
| ---- | ---- | ---------- | ---------- | ----- | ------ | ------ | ---------- | ---- | ----- | ------ |
| I1   | IE   | ID(R2, R3) | EX         | M(空) | WB(R1) |        |            |      |       |        |
| I2   |      | IE         | ID(R2, R4) | EX    | M(空)  | WB(R5) |            |      |       |        |
| I3   |      |            | IE         |       |        |        | ID(R5, R3) | EX   | M(空) | WB(R4) |



####  例2

判断：流水线按序流动时，在RAW、WAR和WAW中，只可能出现RAW相关。

对。当流水线按序流动，其图像如下：

![](https://raw.githubusercontent.com/baichen99/pics/master/img/%E6%88%AA%E5%B1%8F2021-07-10%20%E4%B8%8A%E5%8D%881.12.33.png)

1. I1的2是读数据，I2、I3中的WB是写，都在2其之后，所以不存在WAR(读后写)相关
2. I1的5是写数据，如果I2的3访问到了I1写的寄存器，就出现了RAW(写后读)相关
3. I1的5是写，I2的6是写，在I1的写之后，所以不存在WAW相关



#### 例3456

#### 例4

