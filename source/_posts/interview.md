---
title: 面试问题(计算机基础)
date: 2020-08-5 20:52:45
categories:
- interview
tags:
- os
- database
- golang
- interview
---

## 数据库

### ACID

- A, atomacity 原子性 事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。通常，与某个事务关联的操作具有共同的目标，并且是相互依赖的。如果系统只执行这些操作的一个子集，则可能会破坏事务的总体目标。原子性消除了系统处理操作子集的可能性。

- C, consistency 一致性

  事务在完成时，必须使所有的数据都保持一致状态（各种 constraint 不被破坏）。

- I, isolation 隔离性  一个事务的影响在该事务提交前对其他事务都不可见。

- D, durability 持久性

  事务完成之后，它对于系统的影响是永久性的。该修改即使出现致命的系统故障也将一直保持。

#### 三大范式

https://cloud.tencent.com/developer/article/1415705

https://juejin.im/post/6844904029617651720

##### 1NF:

数据原子性，表中的字段不可再分。eg地区字段可以分解为省份，城市，和具体地址三个字端。

##### 2NF:

在1NF的基础上，消除了部分函数依赖，即每个非主属性完全依赖于主键。

eg：一个选课关系表有（学号，姓名，课号）三个字段，因为一个学生对应多个课程，一个课程对应多个学生，所以（学号，课号）可以唯一确定一条记录。用（学号，课号）作为主键，但是姓名可以根据学号唯一确定，所以姓名部分函数依赖于学号，这不符合第二范式的定义。

**带来的问题**

数据冗余

增删改出现问题 eg：如果想增加一个课程，这个课程如果没有人选就无法添加，如果一个课程只有一个人选，那么退课的时候也会删除课程，如果要更新课程的名称，那就要更新所有包含此课程的记录。

##### 3NF

在2NF的基础上，消除非主属性对主属性的传递函数依赖。

不符合3NF会带来数据冗余和更新异常的问题。（更新异常：有重复的冗余信息，修改时需要同时修改多条记录，否则会出现数据不一致的情况 。）

eg：（学号，系号，系名）中，学号决定系号，系号决定系名，这样存在传递函数依赖学号决定系名。



范式化的优点：

- 可以尽量的减少数据冗余，数据表更新快体积小
- 范式化的更新操作比反范式化更快
- 范式化的表通常比反范式化更小

缺点：

- 对于查询需要对多个表进行关联（导致性能降低）
- 更难进行索引优化



#### 数据库索引

#### B+树






## 计算机网络

osi模型

1. 应用层(数据):是计算机用户以及各种应用程序和网络之间的接口
2. 表示层(数据):它对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传送给会话层。
3. 会话层(数据):不同机器上的用户建立会话

4. 传输层(段):实现网络不同主机上用户进程之间的数据通信，可靠与不可靠的传输，传输层的错误检测，流量控制等
5. 网络层(包):提供逻辑地址(IP)、通过路径选择算法将数据从源端到目的端
6. 数据链路层(帧):将比特流数据封装成帧，增加错误检测与修正等功能，增加可靠性
7. 物理层(比特流):利用物理介质提供物理连接，提供比特流传输

### TCP/IP

TCP/IP模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。

链路层：负责封装和解封装IP报文，发送和接受ARP/RARP报文等。

网络层：负责路由以及把分组报文发送给目标网络或主机。点对点

传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。

应用层：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。

### 链路层

#### ARP协议
1：首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。

2：当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址。

3：当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。

4：源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。

广播发送ARP请求，单播发送ARP响应。

- 作用

  ARP 为 IP 地址到对应的硬件地址提供动态映射。

- 点对点链路使用 ARP 吗?

  不使用

- ARP 高效运行的关键是什么?

  关键是每个主机上都有一个 ARP 的高速缓存。

  

### 传输层

#### TCP UDP简单介绍
TCP提供的是面向连接，可靠的字节流服务。即客户端和服务器交换数据前，必须现在双方之间建立一个TCP连接，之后才能传输数据。并且提供超时重发，流量控制等功能，保证数据能从一端传到另一端。

UDP（User Data Protocol，用户数据报协议）是一个简单的面向数据报的运输层协议。它不提供可靠性，只是把数据报发送出去，但是不能保证它们能到达目的地。由于UDP在传输数据报前不用再客户和服务器之间建立一个连接，且没有超时重发等机制，所以传输速度很快。

**使用场景**

对实时性要求高和高速传输的场合下使用UDP;在可靠性要求低，追求效率的情况下使用UDP;
需要传输大量数据且对可靠性要求高的情况下使用TCP




#### 三次握手

三次握手的目的是为了建立安全可靠的连接。

第一次握手：客户端给服务端发送一个报文，报文中SYN位置1

第二次握手：服务端接收到报文后，就知道客户端想建立一个连接，然后服务端给客户端发送一个确认报文，在这个报文中 ACK位置1

两次握手之后，对于客户端而言，已经知道服务端的接收、发送能⼒是正常的，但是服务端并不能确认客户端的接收能力是否正常，所以要进行第三次握手

第三次握手：客户端给服务端发送报文，报文中ACK位置1

通过三次握手之后，服务端和客户端都知道彼此的发送和接收能力都是正常的，那么这个连接就可以被安全的建立了。

#### 四次挥手
四次挥手也是由客户端首先发起的

第一次挥手：客户端会发送一个报文，在报文中FIN位置1

第二次挥手：当服务端收到这个报文后，会发送报文 ACK=1作为应答，此时服务端知道客户端想和他断开连接，但此时服务端不一定能做好准备，所以此时服务端只能告诉客户端已经收到断开连接的请求

第三次挥手：当服务端做好断开连接的准备时，发送一个报文给客户端，报文中FIN标志位 置1

第四次挥手：当这个报文发给客户端时，客户端同样要给服务端发送一个确认报文，ACK=1

通过这四次挥手就能得出客户端和服务端都做好了断开连接的准备，于是连接可以断开了。

- 为什么客户端发送 ACK 之后不直接关闭，⽽而是要等一阵子才关闭（TIME_WAIT）。

  这其中的原因就是，要确保服务器是否已经收到了ACK 报文。如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到报⽂之后，就知道之前的报⽂文丢失了，然后再次发送 ACK 报⽂。



#### tcp拥塞控制

https://blog.csdn.net/qq_43313035/article/details/89069962

拥塞：对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量随之负荷的增大而下降。

拥塞控制是为了提高网络利用率，降低丢包率。发送方维护一个拥塞窗口。

主要是下面四种机制：



**1- 慢开始**

 慢开始是指在TCP开始发送报文段时先设置拥塞窗口为1。然后指数增加窗口大小

**2-拥塞避免**

当窗口大小>阈值时，拥塞窗口大小增加改为线型增加。

**3- 快速重传**

1. 发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设 置的重传计时器时间到期。
2. 由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量。

**4- 快速恢复**
连续收到3个对数据包的重复确认，发送端就知道需要马上重传。并且把 ssthresh（慢开始门限）和窗口大小设置为当前窗口的一半，然后开始执行拥塞避免算法。



#### tcp流量控制
如果发送端发送数据太快，接收端来不及接收，可能会丢失数据。所以流量控制是控制发送端发送速率，要让接收端来得及接收。

具体就是：

接收方每次收到数据包，可以在发送确定报⽂的时候，同时告诉发送方⾃己的缓存区还剩余多少是空闲的，我们也把缓存区的剩余⼤小称之为接收窗口⼤小。

发送方收到之后，便会调整自己的发送速率，也就是调整自己发送窗口的大小，当发送方收到接收窗口的大小为0时，发送方就会停止发送数据，防止出现大量丢包情况的发生。

发送方如果收到零窗口通知，就会启动计时器。若计时器的时间到期，就会发送一个报文：如果接收方可以接收数据就告诉他此时接收窗口的大小，如果接收大小还是为0，发送方就重新设置计时器。

### 应用层

#### http

[http协议-面试]([https://troywu0.gitbooks.io/interview/content/http%E5%8D%8F%E8%AE%AE.html](https://troywu0.gitbooks.io/interview/content/http协议.html)

http协议是超文本传输协议，它规定了浏览器怎样向万维网请求文档，以及服务器如何把文档传递给浏览器。从层次的角度来看，http协议是一个应用层协议。

在浏览器和服务器之间的请求和响应，必须按照规定的格式和遵循一定格式，这些格式和规则就是http。

HTTP就是一种无状态协议，它对用户的操作没有记忆功能。为了解决这种情况，引出了**Cookie&Session**机制，让浏览器具备了记忆功能

他的工作流程大概是这样的：每个站点都有一个服务器进程，不断监听tcp的80端口，查看是否有浏览器向它发送连接请求。一旦监听到连接请求并建立了tcp连接之后，浏览器就向服务器发出页面请求，服务器就要返回所请求的页面作为响应。最后tcp连接被释放。



#### [从输入URL到页面加载发生了什么](https://segmentfault.com/a/1190000013522717)

1. 浏览器请求dns解析域名的ip地址
3. 浏览器和服务器建立tcp连接
4. 浏览器向服务器发出请求
5. 服务器给出响应，并把相应的文件发送给浏览器
6. 释放tcp连接
7. 浏览器渲染文本



#### http 1.0 / 1.1

http1.1相较于1.0有以下新的特性：

- 支持长连接   一个tcp连接上有多个请求，不用重复建立和断开连接，提高带宽利用率
- 增加host字段
- 新增了24个状态码 （410表示对象被永久删除）
- 引入range字段，支持之请求资源的一部分，节省了带宽
- 缓存控制字段 cache-control  服务端响应时，回传**max-age参数**，那么客户端在下次请求时，根据上次回传的max-age值，首先判断缓存的**相对时间**如果还未超过时间，则不发起请求，直接从Cache中读取。反之，则重新请求。
- 支持断点传输

#### http 2.0

- 支持二进制传输
- 服务器推送：服务器可以额外的向客户端推送资源，而无需客户端明确的请求
- 多路复用，一个Tcp中多个http请求是并行的



#### https

[https加密原理](https://blog.csdn.net/qq_31967569/article/details/84296432)

**发送者->接收者：**

1. message通过hash生成消息摘要
2. 用private key加密摘要生成签名
3. 把message和签名一起发送给接收者
4. 接收者对message进行hash处理得到消息摘要，再用public key把签名解密，两者相等表示验证成功

**公钥证书：**

1. 服务端生成密钥对，私钥自己保管，公钥交给CA
2. CA生成密钥对，用自己的私钥对服务端的公钥进行签名生成数字证书，证书中包含服务端公钥
3. 客户端获取证书
4. 用公钥对证书进行签名认证，成功说明公钥匙服务端的
5. 客户端可以用公钥加密消息发送给服务端
6. 服务端收到密文后用私钥解密

[https流程](https://segmentfault.com/a/1190000019976390)

[流程详细解释](https://www.jianshu.com/p/e30a8c4fa329)

1. client请求server获取证书
2. 客户端验证证书合法性
3. 若合法，则生成一个随机值（之后对称加密信息要用到）
4. 用证书中的公钥对这个随机值加密，发送给服务端
5. 服务端用私钥对密文解密，获取随机值
6. 服务端将随机值和信息混合在一起进行对称加密，发送给客户端
7. 客户端解密



#### get post 区别

- 在浏览器回退时，GET是无害的，POST会再次提交请求。
- GET请求参数会被完整保留在浏览历史记录里，而POST中的参数不会被保留
- GET参数通过URL传递，POST放在Request body中。
- GET 请求在url中传送的参数有长度限制，而POST没有
- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。

- GET产生一个TCP数据包；POST产生两个TCP数据包。

  对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；

  而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

#### cookie session区别

- cookie是把用户的数据写在用户本地浏览器上, 其他网站也可以扫描使用你的cookie，容易泄露自己网站用户的隐私，而且一般浏览器对单个网站站点有cookie数量与大小的限制。
- Session是把用户的数据写在用户的独占session上，存储在服务器上，一般只将session的id存储在cookie中。但将数据存储在服务器对服务器的成本会高。 
- session是由服务器创建的，开发人员可以在服务器上通过request对象的getsession方法得到session 一般情况，登录信息等重要信息存储在session中，其他信息存储在cookie中
- 工作流程：
	服务器会为每一个访问服务器的用户创建一个session对象，并且把session对象的id保存在本地cookie上，只要用户再次访问服务器时，带着session的id，服务器就会匹配用户在服务器上的session，根据session中的数据，还原用户上次的浏览状态或提供其他人性化服务。

#### url各部分都是什么

　protocol :// hostname[:port] / path / [?query]

#### dns
dns的作用是把域名和主机名转换成ip地址。

解析流程：

（需要明确的是，每一级域名都有自己的NS记录，NS记录指向该级域名的域名服务器。这些服务器知道下一级域名的各种记录。）

dns解析是分级查询。

[dns查询原理](https://segmentfault.com/a/1190000013522717)





## 操作系统

#### 进程线程区别

**（1）联系**

 线程是进程的一部分，一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。

**（2）区别：**

根本区别：进程是CPU资源分配的基本单位，线程是独立运行和独立调度的基本单位（CPU上真正运行的是线程）。

地址空间：线程共享本进程的地址空间，而进程之间是独立的地址空间。

资源方面：线程本身不拥有系统资源，只拥有一些在运行过程中必不可少的资源（如程序计数器，寄存器等），所以线程之间切换的开销比较小，而进程之间的切换开销会大一些。



#### 协程

协程是一种用户态的轻量级线程，**协程的调度完全由用户控制**。协程切换开销比较小。

线程是抢占式的调度，而协程是协同式的调度，协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力（协程不支持并行）。




##### 应用场景

[什么是CPU密集型、IO密集型](https://www.jianshu.com/p/1f5195dcc75b)

**1）需要频繁创建销毁的优先用线程**

**2)   线程和协程推荐在IO密集型的任务(比如网络调用)中使用，而在CPU密集型的任务中，表现较差。**



#### 死锁

[产生死锁的四个条件和解决办法](https://www.cnblogs.com/shan1393/p/9046140.html)



#### 进程调度算法

[批处理系统、分时处理系统、实时处理系统简介](https://blog.csdn.net/u010889616/article/details/48424501)



#### 进程通信

https://zhuanlan.zhihu.com/p/135395279

目的：实现信息交换，实现进程的互斥和同步

1. 共享内存

   在内存中划出一块共享存储区域，各个进程可通过对该共享区的读写来实现通信。

   **特点**：  
    ​   1. 不用从用户态到内核态的频繁切换和拷贝数据，直接从内存中读取就可以。
    ​   2. 共享内存是临界资源，所以需要操作时必须要保证原子性。使用信号量或者互斥锁都可以。

2. 管道通信系统

   管道指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件。发送进程以字符流形式将数据送入管道，接收进程从管道中接受数据。

   **特点**:
    1. 半双工。一个进程对pipe进行读写时，另一进程需要等待。
    2. 数据单向流动。
    3. 只能在父子进程或兄弟进程间使用

   named_pipe 命名管道：可以在无亲缘关系的进程之间进行通讯

3. socket

    **优点**：1）传输数据为字节级，传输数据可自定义，数据量小效率高；2）传输数据时间短，性能高；3) 适合于客户端和服务器端之间信息实时交互；4) 可以加密,数据安全性强

   **缺点**：1) 需对传输的数据进行解析，转化成应用级的数据。

4. 消息队列

   消息队列是消息的链表。克服了管道只能承载无格式字节流以及缓冲区大小受限等特点。

   可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题

5. 信号量

   本质是一个计数器，用pv操作实现进程间的通信和互斥。

   ​		PV操作用于同一进程，实现互斥。

   ​		PV操作用于不同进程，实现同步。



## 项目

- golang

  http://golang.iswbm.com/en/latest/chapters/p02.html

- jwt

  http://blacston.com/2019/07/26/jwt-go/#more

- [cors](https://segmentfault.com/a/1190000011450120)

- [mvc架构](https://blog.csdn.net/dc8899/article/details/21336467)

- orm

- [restful](https://www.cnblogs.com/wangyongsong/articles/10004370.html)

## 其他

### 排序算法

[稳定性](https://www.cnblogs.com/codingmylife/archive/2012/10/21/2732980.html)

![](https://img-blog.csdn.net/20180117112126129?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjQyODAxMg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)



### docker

docker将应用程序及其所有依赖项打包在一起。这可以保证无论其环境如何，软件始终运行相同。



[面试总结](https://hit-alibaba.github.io/interview/basic/arch/Concurrency.html)





